name: "Update Configuration and Build"

on:
  workflow_dispatch:
  push:

jobs:
  update:
    name: "Update Configuration & Build"
    runs-on: ubuntu-latest
    permissions: write-all

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.10.0"

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build project
        run: |
          bun add -DE @vercel/ncc
          echo "Deleting previous dist..."
          rm -rf dist
          echo "Compiling plugin..."
          bun ncc build src/action.ts --external "./tests" -o dist/plugin
          echo "Compiling plugin types..."
          bun ncc build src/types/plugin-input.ts --external "./tests" -o plugin

      - name: Replace __dirname with import.meta.dirname
        run: |
          sed -i 's/__dirname/import.meta.dirname/g' dist/plugin/index.js

      - name: Update manifest configuration JSON
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs').promises;
            const path = require('path');

            async function updateManifest() {
              const manifestPath = 'manifest.json';
              const pluginPath = path.resolve('plugin', 'index.js');

              let pluginSettingsSchema;
              try {
                // First, try to load as ESM
                try {
                  const pluginModule = await import(`file://${pluginPath}`);
                  pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                  if (!pluginSettingsSchema) {
                    throw new Error('pluginSettingsSchema not found in the ESM module');
                  }
                } catch (esmError) {
                  // If ESM import fails, try loading as CJS
                  try {
                    const pluginModule = require(pluginPath);
                    pluginSettingsSchema = pluginModule.pluginSettingsSchema;

                    if (!pluginSettingsSchema) {
                      throw new Error('pluginSettingsSchema not found in the CJS module');
                    }
                  } catch (cjsError) {
                    console.error('Error loading module as ESM and CJS:', esmError, cjsError);
                    process.exit(1);
                  }
                }
              } catch (error) {
                console.error('Error loading module:', error);
                process.exit(1);
              }

              const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));
              manifest["configuration"] = pluginSettingsSchema;

              function customReviver(key, value) {
                if (typeof value === "object" && value !== null) {
                  if ("properties" in value && "required" in value) {
                    const requiredFields = new Set(value.required);
                    for (const [propKey, propValue] of Object.entries(value.properties)) {
                      if (typeof propValue === 'object' && 'default' in propValue) {
                        requiredFields.delete(propKey);
                      }
                    }
                    value.required = Array.from(requiredFields);
                    if (value.required.length === 0) {
                      delete value.required;
                    }
                  }

                  // Recursively apply to nested objects and arrays
                  if (Array.isArray(value)) {
                    return value.map(item => JSON.parse(JSON.stringify(item), customReviver));
                  } else {
                    return Object.fromEntries(
                      Object.entries(value).map(([k, v]) => [k, JSON.parse(JSON.stringify(v), customReviver)])
                    );
                  }
                }
                return value;
              }

              const updatedManifest = JSON.stringify(manifest, customReviver, 2);
              await fs.writeFile(manifestPath, updatedManifest, 'utf8');
            }
            updateManifest()

      - name: Format manifest
        run: npx prettier --write manifest.json

      - name: Copy reassembly script
        run: |
          cp .github/scripts/reassembly-esm.js dist/index.js
          cp dist/plugin/package.json dist/package.json

      - name: Create GitHub App token
        if: env.APP_ID != '' && env.APP_PRIVATE_KEY != ''
        uses: actions/create-github-app-token@v1
        id: get_installation_token
        with:
          app-id: ${{ env.APP_ID }}
          private-key: ${{ env.APP_PRIVATE_KEY }}

      - name: Update manifest.json and dist folder
        env:
          GITHUB_TOKEN: ${{ steps.get_installation_token.outputs.token || github.token }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
          COMMIT_MESSAGE: "chore: [skip ci] updated manifest.json and dist build"
          MANIFEST_PATH: manifest.json
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: |
          # Stage files using git commands
          git add manifest.json
          find dist \( -name "*.js" -o -name "*.json" \) -print0 | xargs -0 git add -f

          echo "Checking for staged changes..."
          # Check if git add actually staged anything
          if ! git diff --cached --quiet; then
            echo "Changes detected. Committing and pushing..."
            git commit -m "$COMMIT_MESSAGE"
            git push
            echo "Changes committed and pushed successfully."
          else
            echo "No changes detected in manifest or dist folder."
          fi
